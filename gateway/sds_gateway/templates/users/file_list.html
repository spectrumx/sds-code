{# templates/users/file_list.html #}
{% extends "base.html" %}

{% load static %}

{% block bodyclass %}
    hero-white-page
{% endblock bodyclass %}
{% block body %}
    <!-- Add Font Awesome for sort arrows -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <!-- Add noUiSlider CSS first -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" />
    <!-- Add file-list.css for upload modal styling -->
    <link rel="stylesheet" href="{% static 'css/file-list.css' %}" />
    <!-- Add noUiSlider JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
    <style>
        .clear-search-hidden {
            display: none;
        }
    </style>
    <!-- CSRF Token for JavaScript -->
    {% csrf_token %}
    <!-- System-wide notifications -->
    {% if system_notifications %}
        <div class="container">
            {% for notification in system_notifications %}
                <div class="alert alert-dismissible alert-{{ notification.level }}">{{ notification.user_message }}</div>
            {% endfor %}
        </div>
    {% endif %}
    {% if messages %}
        <div class="container">
            {% for message in messages %}
                <div class="alert alert-dismissible {% if message.tags %}alert-{{ message.tags }}{% endif %}">
                    {{ message }}
                    <button type="button"
                            class="btn-close"
                            data-bs-dismiss="alert"
                            aria-label="Close"></button>
                </div>
            {% endfor %}
        </div>
    {% endif %}
    <div id="upload-alert-container" class="container mt-3"></div>
    <div class="container-fluid px-5 pt-4">
        <!-- Headers Row -->
        <div class="row mb-1">
            <div class="col-12">
                <h1 class="mb-0 text-start">Captures</h1>
            </div>
        </div>
        <!-- Content Row -->
        <div class="row">
            <!-- Sidebar Filters -->
            <aside class="col-md-3 mb-4">
                <div class="sidebar-filters">
                    <div class="accordion" id="filtersAccordion">
                        <!-- Frequency -->
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="headingFrequency">
                                <button class="accordion-button collapsed"
                                        type="button"
                                        data-bs-target="#collapseFrequency"
                                        aria-expanded="false"
                                        aria-controls="collapseFrequency">
                                    <i class="fas fa-signal me-2"></i>
                                    Center Frequency
                                </button>
                            </h2>
                            <div id="collapseFrequency" class="accordion-collapse collapse">
                                <div class="accordion-body">
                                    <label for="frequency-range" class="form-label">Center Frequency Range</label>
                                    <div id="frequency-range-slider"
                                         class="mt-3 mb-3"
                                         role="slider"
                                         aria-valuemin="0"
                                         aria-valuemax="10"
                                         aria-valuenow="0,10"
                                         aria-valuetext="Frequency range from 0.0 GHz to 10.0 GHz"></div>
                                    <div class="d-flex justify-content-between mb-3">
                                        <span id="frequency-range-lower" aria-live="polite">0 GHz</span>
                                        <span id="frequency-range-upper" aria-live="polite">10 GHz</span>
                                    </div>
                                    <div class="row mt-3">
                                        <div class="col-6">
                                            <label for="centerFreqMinInput" class="form-label small">Min (GHz)</label>
                                            <input type="number"
                                                   id="centerFreqMinInput"
                                                   class="form-control form-control-sm"
                                                   min="0"
                                                   max="10"
                                                   step="0.1"
                                                   value="0"
                                                   placeholder="0" />
                                        </div>
                                        <div class="col-6">
                                            <label for="centerFreqMaxInput" class="form-label small">Max (GHz)</label>
                                            <input type="number"
                                                   id="centerFreqMaxInput"
                                                   class="form-control form-control-sm"
                                                   min="0"
                                                   max="10"
                                                   step="0.1"
                                                   value="10"
                                                   placeholder="10" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Date -->
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="headingDate">
                                <button class="accordion-button collapsed"
                                        type="button"
                                        data-bs-target="#collapseDate"
                                        aria-expanded="false"
                                        aria-controls="collapseDate">
                                    <i class="fas fa-calendar me-2"></i>
                                    Date Range
                                </button>
                            </h2>
                            <div id="collapseDate" class="accordion-collapse collapse">
                                <div class="accordion-body">
                                    <div class="row">
                                        <div class="col mb-3">
                                            <label class="form-label" for="start_date">Start Date</label>
                                            <input type="date" class="form-control" id="start_date" name="date_start" />
                                        </div>
                                        <div class="col">
                                            <label class="form-label" for="end_date">End Date</label>
                                            <input type="date" class="form-control" id="end_date" name="date_end" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Receiver -->
                        <!--
          <div class="accordion-item mb-2">
            <h2 class="accordion-header" id="headingReceiver">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseReceiver" aria-expanded="false" aria-controls="collapseReceiver">
                Receiver
              </button>
            </h2>
            <div id="collapseReceiver" class="accordion-collapse collapse" aria-labelledby="headingReceiver" data-bs-parent="#filtersAccordion">
              <div class="accordion-body">
                <select class="form-select" id="receiverSelect">
                  <option value="">Select Receiver</option>
                  <option value="receiver1">Receiver 1</option>
                  <option value="receiver2">Receiver 2</option>
                  <option value="receiver3">Receiver 3</option>
                </select>
              </div>
            </div>
          </div>
-->
                        <!-- Category -->
                        <!--
          <div class="accordion-item">
            <h2 class="accordion-header" id="headingCategory">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCategory" aria-expanded="false" aria-controls="collapseCategory">
                [Category]
              </button>
            </h2>
            <div id="collapseCategory" class="accordion-collapse collapse" aria-labelledby="headingCategory" data-bs-parent="#filtersAccordion">
              <div class="accordion-body">
                <select class="form-select" id="categorySelect">
                  <option value="">Select Category</option>
                  <option value="category1">Category 1</option>
                  <option value="category2">Category 2</option>
                  <option value="category3">Category 3</option>
                </select>
              </div>
            </div>
          </div>
          -->
                    </div>
                    <div class="d-flex gap-3 mt-4">
                        <button class="btn btn-primary flex-fill"
                                type="button"
                                id="apply-filters-btn">Apply Filters</button>
                        <button class="btn btn-secondary flex-fill"
                                type="button"
                                id="clear-filters-btn">Clear Filters</button>
                    </div>
                </div>
            </aside>
            <!-- Main Content -->
            <main class="col-md-9 pt-0">
                <!-- Search Form -->
                <form id="search-form"
                      role="search"
                      aria-label="Search captures"
                      class="text-start mt-0">
                    <div class="row g-3 mb-3">
                        <div class="col-12">
                            <div class="d-flex justify-content-between align-items-center">
                                <!-- Search Input Group -->
                                <div class="flex-grow-1 me-3">
                                    <label for="search-input" class="visually-hidden">Search captures</label>
                                    <div class="input-group">
                                        <div class="position-relative flex-grow-1">
                                            <input type="search"
                                                   class="form-control pe-5"
                                                   id="search-input"
                                                   placeholder="Search captures..."
                                                   value="{{ search }}"
                                                   aria-describedby="searchHelp" />
                                            <button type="button"
                                                    class="btn btn-link position-absolute end-0 top-50 translate-middle-y text-secondary px-3 clear-search-hidden"
                                                    id="clear-search-btn"
                                                    aria-label="Clear search">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                        <button class="btn btn-primary"
                                                type="submit"
                                                id="search-btn"
                                                aria-label="Search captures">
                                            <i class="fas fa-search" aria-hidden="true"></i>
                                            <span class="d-none d-sm-inline ms-1">Search</span>
                                        </button>
                                    </div>
                                </div>
                                <!-- Upload Button Group -->
                                <div class="flex-shrink-0">
                                    <div class="input-group">
                                        <button type="button"
                                                class="btn btn-success"
                                                data-bs-toggle="modal"
                                                data-bs-target="#uploadCaptureModal">
                                            <i class="fas fa-upload"></i> Upload Capture
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
                <!-- Loading indicator -->
                <div id="loading-indicator" class="text-center py-3 d-none">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2 text-muted">Searching captures...</p>
                </div>
                <!-- Upload Capture Modal -->
                <div class="modal fade"
                     id="uploadCaptureModal"
                     tabindex="-1"
                     aria-labelledby="uploadCaptureModalLabel"
                     aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <form id="uploadCaptureForm" enctype="multipart/form-data">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="uploadCaptureModalLabel">Upload Files & Create Capture</h5>
                                    <button type="button"
                                            class="btn-close"
                                            data-bs-dismiss="modal"
                                            aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <!-- Progress Bar Section (initially hidden) -->
                                    <div id="checkingProgressSection" class="mt-3 progress-section-hidden">
                                        <div class="d-flex align-items-center">
                                            <div class="spinner-border spinner-border-sm me-2" role="status">
                                                <span class="visually-hidden">Processing...</span>
                                            </div>
                                            <div class="flex-grow-1">
                                                <div class="progress progress-bar-custom">
                                                    <div id="checkingProgressBar"
                                                         class="progress-bar"
                                                         role="progressbar"
                                                         class="progress-bar progress-bar-width-0"></div>
                                                </div>
                                            </div>
                                            <small class="ms-2 text-muted" id="checkingProgressText">0%</small>
                                        </div>
                                        <small class="text-muted" id="progressMessage">Processing files for upload...</small>
                                    </div>
                                    <!-- File Selection Section -->
                                    <label for="captureFileInput" class="form-label">Select a folder to upload</label>
                                    <input type="file"
                                           id="captureFileInput"
                                           name="files"
                                           multiple
                                           webkitdirectory
                                           directory
                                           class="form-control" />
                                    <!-- Capture Type Selection -->
                                    <div class="mt-3">
                                        <label for="captureTypeSelect" class="form-label">Capture Type</label>
                                        <select id="captureTypeSelect"
                                                name="capture_type"
                                                class="form-select"
                                                required>
                                            <option value="">Select capture type...</option>
                                            <option value="drf">DigitalRF</option>
                                            <option value="rh">RadioHound</option>
                                        </select>
                                        <div class="form-text">
                                            <strong>DigitalRF:</strong> For .h5/.hdf5 files with channel-based structure
                                            <br />
                                            <strong>RadioHound:</strong> For .rh.json files with scan group metadata
                                        </div>
                                    </div>
                                    <!-- Channel Input (shown for DigitalRF) -->
                                    <div id="channelInputGroup" class="mt-3 hidden-input-group">
                                        <label for="captureChannelsInput" class="form-label">Capture Channel Names (comma-separated)</label>
                                        <input type="text"
                                               id="captureChannelsInput"
                                               name="channels"
                                               class="form-control"
                                               placeholder="e.g. ch1,ch2,ch3" />
                                        <div class="form-text">Required for DigitalRF captures</div>
                                    </div>
                                    <!-- Scan Group Input (shown for RadioHound) -->
                                    <div id="scanGroupInputGroup" class="mt-3 hidden-input-group">
                                        <label for="captureScanGroupInput" class="form-label">Scan Group</label>
                                        <input type="text"
                                               id="captureScanGroupInput"
                                               name="scan_group"
                                               class="form-control"
                                               placeholder="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" />
                                        <div class="form-text">For RadioHound captures, optional UUID</div>
                                    </div>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                    <button type="submit" class="btn btn-primary" id="uploadSubmitBtn">
                                        <span class="upload-text">Check & Upload Files</span>
                                        <span class="upload-spinner d-none">
                                            <span class="spinner-border spinner-border-sm"
                                                  role="status"
                                                  aria-hidden="true"></span>
                                            Uploading...
                                        </span>
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
                <!-- Upload Result Modal -->
                <div class="modal fade"
                     id="uploadResultModal"
                     tabindex="-1"
                     aria-labelledby="uploadResultModalLabel"
                     aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="uploadResultModalLabel">Upload Result</h5>
                                <button type="button"
                                        class="btn-close"
                                        data-bs-dismiss="modal"
                                        aria-label="Close"></button>
                            </div>
                            <div class="modal-body" id="uploadResultModalBody">
                                <!-- Content will be set by JS -->
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Captures Table -->
                {% include "users/partials/captures_page_table.html" %}
            </main>
        </div>
    </div>
    <!-- Capture Details Modal -->
    {% include "users/partials/capture_modal.html" %}
{% endblock body %}
{% block javascript %}
    {{ block.super }}
    <script src="{% static 'js/components.js' %}"></script>
    <script src="{% static 'js/file-list.js' %}"></script>
    <script src="{% static 'js/userSearchComponent.js' %}"></script>
    <script>
        // Initialize noUiSlider for frequency range
        document.addEventListener('DOMContentLoaded', function() {
            const frequencyRangeSlider = document.getElementById('frequency-range-slider');
            if (frequencyRangeSlider) {
                noUiSlider.create(frequencyRangeSlider, {
                    start: [0, 10],
                    connect: true,
                    range: {
                        'min': 0,
                        'max': 10
                    },
                    step: 0.1,
                    format: {
                        to: function(value) {
                            return parseFloat(value).toFixed(1);
                        },
                        from: function(value) {
                            return parseFloat(value);
                        }
                    }
                });

                const lowerValue = document.getElementById('frequency-range-lower');
                const upperValue = document.getElementById('frequency-range-upper');
                const minInput = document.getElementById('centerFreqMinInput');
                const maxInput = document.getElementById('centerFreqMaxInput');

                // Track user interaction with slider
                let userInteractedWithSlider = false;

                frequencyRangeSlider.noUiSlider.on('update', function(values, handle) {
                    const value = parseFloat(values[handle]);
                    if (handle === 0) {
                        lowerValue.textContent = value + ' GHz';
                        minInput.value = value;
                        frequencyRangeSlider.setAttribute('aria-valuetext', `Frequency range from ${value} GHz to ${parseFloat(values[1])} GHz`);
                    } else {
                        upperValue.textContent = value + ' GHz';
                        maxInput.value = value;
                        frequencyRangeSlider.setAttribute('aria-valuetext', `Frequency range from ${parseFloat(values[0])} GHz to ${value} GHz`);
                    }
                });

                // Mark as interacted when user changes slider
                frequencyRangeSlider.noUiSlider.on('change', function() {
                    userInteractedWithSlider = true;
                    // Trigger the global tracking
                    if (window.initializeFrequencySlider) {
                        // Update the global interaction tracking
                        const event = new Event('change');
                        minInput.dispatchEvent(event);
                    }
                });

                // Update slider when input values change
                minInput.addEventListener('change', function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 10) {
                        frequencyRangeSlider.noUiSlider.set([value, null]);
                    }
                });

                maxInput.addEventListener('change', function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 10) {
                        frequencyRangeSlider.noUiSlider.set([null, value]);
                    }
                });

                // Initialize from URL parameters after slider is created
                if (window.initializeFrequencySlider) {
                    window.initializeFrequencySlider();
                }
            }
        });

        // Initialize share modals for captures
        document.addEventListener('DOMContentLoaded', function() {
            // Create a UserSearchHandler for each share modal
            document.querySelectorAll('.modal[data-item-uuid]').forEach(modal => {
                const itemUuid = modal.getAttribute('data-item-uuid');
                const itemType = modal.getAttribute('data-item-type');
                if (window.UserSearchHandler) {
                    const handler = new window.UserSearchHandler();
                    // Store the handler on the modal element
                    modal.userSearchHandler = handler;
                }

                // On modal show, set the item info and call init()
                modal.addEventListener('show.bs.modal', function() {
                    if (modal.userSearchHandler) {
                        modal.userSearchHandler.setItemInfo(itemUuid, itemType);
                        modal.userSearchHandler.init();
                    }
                });

                // On modal hide, reset all selections and entered data
                modal.addEventListener('hidden.bs.modal', function() {
                    if (modal.userSearchHandler) {
                        modal.userSearchHandler.resetAll();
                    }
                });
            });

            // Check for download alert messages
            const downloadAlert = sessionStorage.getItem('captureDownloadAlert');
            if (downloadAlert) {
                const alertData = JSON.parse(downloadAlert);
                showAlert(alertData.message, alertData.type);
                sessionStorage.removeItem('captureDownloadAlert');
            }
        });

        // Function to show alerts (same as in dataset-list.js)
        function showAlert(message, type) {
            const alertClass = type === "success" ? "alert-success" : "alert-danger";
            const alertHtml = `
                <div class="alert ${alertClass} alert-dismissible fade show" role="alert">
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            `;

            const alertContainer = document.querySelector(".container-fluid");
            if (alertContainer) {
                alertContainer.insertAdjacentHTML("afterbegin", alertHtml);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Upload Capture Modal JS

            let isProcessing = false; // Flag to track if processing is active

            // Reset cancellation state on page load

            // Add page refresh/close confirmation
            let uploadInProgress = false;

            // Clear any existing result modals on page load
            const existingResultModal = document.getElementById('uploadResultModal');
            if (existingResultModal) {
                const modalInstance = bootstrap.Modal.getInstance(existingResultModal);
                if (modalInstance) {
                    modalInstance.hide();
                }
            }

            // Clear any upload-related session storage
            if (sessionStorage.getItem('uploadInProgress')) {
                sessionStorage.removeItem('uploadInProgress');
            }

            // Handle beforeunload event (page refresh/close)
            window.addEventListener('beforeunload', function(e) {
                if (isProcessing || uploadInProgress || sessionStorage.getItem('uploadInProgress')) {
                    e.preventDefault();
                    e.returnValue = 'Upload in progress will be aborted. Are you sure you want to leave?';
                    return e.returnValue;
                }
            });

            // Handle visibility change (tab close/minimize)
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'hidden' && uploadInProgress) {
                    // Page hidden during upload
                }
            });

            // Get button references
            const cancelButton = document.querySelector('#uploadCaptureModal .btn-secondary');
            const closeButton = document.querySelector('#uploadCaptureModal .btn-close');
            const submitButton = document.getElementById('uploadSubmitBtn');

            // Store abort controller reference for cancellation
            let currentAbortController = null;

            // Reset cancellation state when modal is opened
            document.getElementById('uploadCaptureModal').addEventListener('show.bs.modal', function() {
                isProcessing = false;
                currentAbortController = null;
            });

            // Reset cancellation state when files are selected
            document.getElementById('captureFileInput').addEventListener('change', function() {

                isProcessing = false;
                currentAbortController = null;
            });

            // Reset cancellation state when modal is hidden
            document.getElementById('uploadCaptureModal').addEventListener('hidden.bs.modal', function() {
                isProcessing = false;
                currentAbortController = null;
            });

            // Handle cancel button click
            let cancelRequested = false;

            // Helper function to handle cancellation logic
            function handleCancellation(buttonType) {
                if (isProcessing) {
                    // Cancel processing
                    cancelRequested = true;

                    // Abort current upload if controller exists
                    if (currentAbortController) {
                        currentAbortController.abort();
                    }

                    // Update UI immediately based on button type
                    if (buttonType === 'cancel') {
                        cancelButton.textContent = 'Cancelling...';
                        cancelButton.disabled = true;
                    } else if (buttonType === 'close') {
                        closeButton.disabled = true;
                        closeButton.style.opacity = '0.5';
                    }

                    // Update progress message
                    const progressMessage = document.getElementById('progressMessage');
                    if (progressMessage) {
                        progressMessage.textContent = 'Cancelling upload...';
                    }

                    // Force UI reset after a short delay to ensure it happens
                    setTimeout(() => {
                        if (cancelRequested) {
                            resetUIState();
                        }
                    }, 500);
                }
                // If not processing, let the normal button behavior handle it
            }

            cancelButton.addEventListener('click', function() {
                handleCancellation('cancel');
            });

            // Handle close button (X) click - same logic as cancel button
            closeButton.addEventListener('click', function() {
                handleCancellation('close');
            });

            // Helper function to check for large files
            function checkForLargeFiles(files, cancelButton, submitButton) {
                const progressSection = document.getElementById('checkingProgressSection');
                const LARGE_FILE_THRESHOLD = 512 * 1024 * 1024; // 512MB in bytes
                const largeFiles = files.filter(file => file.size > LARGE_FILE_THRESHOLD);

                if (largeFiles.length > 0) {
                    // Reset UI state
                    progressSection.style.display = 'none';
                    cancelButton.textContent = 'Cancel';
                    cancelButton.classList.remove('btn-warning');
                    submitButton.disabled = false;

                    // Create alert message
                    const largeFileNames = largeFiles.map(file => file.name).join(', ');
                    const alertMessage = `Large files detected (over 512MB): ${largeFileNames}\n\n` +
                        `Please:\n` +
                        `1. Skip these large files and upload the remaining files, or\n` +
                        `2. Use the SpectrumX SDK (https://pypi.org/project/spectrumx/) to upload large files and add them to your capture.\n\n` +
                        `Large files may cause issues with the web interface.`;

                    alert(alertMessage);
                    return true; // Indicates large files were found
                }

                return false; // No large files found
            }

            // Helper function to check files for duplicates
            async function checkFilesForDuplicates(files, cancelButton, submitButton) {
                // Local progress bar variables
                const progressSection = document.getElementById('checkingProgressSection');
                const progressBar = document.getElementById('checkingProgressBar');
                const progressText = document.getElementById('checkingProgressText');
                const progressMessage = document.getElementById('progressMessage');

                // Show progress section
                progressSection.style.display = 'block';
                progressMessage.textContent = 'Processing files for upload...';

                // Update UI to show processing state
                cancelButton.textContent = 'Cancel Processing';
                cancelButton.classList.add('btn-warning');
                submitButton.disabled = true;

                // Initialize variables for file checking
                window.filesToSkip = new Set();
                window.fileCheckResults = new Map();
                const totalFiles = files.length;

                // Check each file for duplicates with progress
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];

                    // Update progress
                    const progress = Math.round(((i + 1) / totalFiles) * 100);
                    progressBar.style.width = progress + '%';
                    progressText.textContent = progress + '%';

                    // Calculate BLAKE3 hash
                    const buffer = await file.arrayBuffer();
                    const hasher = await hashwasm.createBLAKE3();
                    hasher.init();
                    hasher.update(new Uint8Array(buffer));
                    const hashHex = hasher.digest('hex');

                    // Calculate directory path
                    let directory = "/";
                    if (file.webkitRelativePath) {
                        const pathParts = file.webkitRelativePath.split('/');
                        if (pathParts.length > 1) {
                            pathParts.pop();
                            directory = "/" + pathParts.join("/");
                        }
                    }

                    // Check if file exists
                    const checkData = {
                        directory: directory,
                        filename: file.name,
                        checksum: hashHex
                    };

                    try {
                        const response = await fetch("{% url 'users:check_file_exists' %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify(checkData)
                        });
                        const data = await response.json();

                        // Store the result
                        const fileKey = `${directory}/${file.name}`;
                        window.fileCheckResults.set(fileKey, {
                            file: file,
                            directory: directory,
                            filename: file.name,
                            checksum: hashHex,
                            data: data.data
                        });

                        // Mark for skipping if file exists in tree
                        if (data.data && data.data.file_exists_in_tree === true) {
                            window.filesToSkip.add(fileKey);
                        }


                    } catch (error) {
                        // Error checking file
                    }

                    // Check for cancellation after each file check
                    if (cancelRequested) {
                        break;
                    }
                }
                progressSection.style.display = 'none';

                // Check if cancellation was requested during file checking
                if (cancelRequested) {
                    // Small delay to ensure UI updates are visible
                    progressSection.style.display = 'none';
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Show alert for duplicate checking cancellation
                    alert('Processing cancelled. No files were uploaded.');

                    throw new Error('Upload cancelled by user');
                }
            }

            // Helper function to handle skipped files upload
            async function handleSkippedFilesUpload(allRelativePaths, abortController) {
                // Create form data for skipped files case
                const skippedFormData = new FormData();

                // Always add all relative paths for capture creation
                allRelativePaths.forEach(path => {
                    skippedFormData.append('all_relative_paths', path);
                });

                // Add other form fields
                const captureType = document.getElementById('captureTypeSelect').value;
                skippedFormData.append('capture_type', captureType);

                if (captureType === 'drf') {
                    const channels = document.getElementById('captureChannelsInput').value;
                    skippedFormData.append('channels', channels);
                } else if (captureType === 'rh') {
                    const scanGroup = document.getElementById('captureScanGroupInput').value;
                    skippedFormData.append('scan_group', scanGroup);
                }

                // Don't send chunk information for skipped files
                // This ensures capture creation happens

                const response = await fetch("{% url 'users:upload_capture' %}", {
                    method: 'POST',
                    body: skippedFormData,
                    signal: abortController.signal
                });

                const result = await response.json();
                return result;
            }

            // Helper function to calculate total chunks
            function calculateTotalChunks(filesToUpload, chunkSizeBytes) {
                let totalChunks = 0;
                let tempChunkSize = 0;
                let tempChunkFiles = 0; // Track number of files in current chunk (mirrors currentChunk.length)

                console.log('=== CHUNK CALCULATION DEBUG ===');
                console.log('Files to upload:', filesToUpload.length);
                console.log('Chunk size limit:', (chunkSizeBytes / (1024 * 1024)).toFixed(1), 'MB');

                for (let i = 0; i < filesToUpload.length; i++) {
                    const file = filesToUpload[i];
                    const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
                    console.log(`\nFile ${i + 1}: ${file.name}`);
                    console.log(`  Size: ${fileSizeMB} MB`);
                    console.log(`  Current tempChunkSize: ${(tempChunkSize / (1024 * 1024)).toFixed(2)} MB`);
                    console.log(`  Current tempChunkFiles: ${tempChunkFiles}`);

                    // Check if this file would exceed the chunk limit (mirrors upload logic exactly)
                    if (tempChunkSize + file.size > chunkSizeBytes && tempChunkFiles > 0) {
                        // Current chunk would exceed size limit, start new chunk
                        const wouldBeSize = ((tempChunkSize + file.size) / (1024 * 1024)).toFixed(2);
                        console.log(`  -> CHUNK FULL: ${wouldBeSize} MB > ${(chunkSizeBytes / (1024 * 1024)).toFixed(1)} MB`);
                        console.log(`  -> Creating new chunk. Total chunks: ${totalChunks + 1}`);
                        totalChunks++;
                        tempChunkSize = 0;
                        tempChunkFiles = 0;
                    }

                    // Now add the file to the current chunk
                    if (file.size > chunkSizeBytes) {
                        // Large file gets its own chunk
                        console.log(`  -> LARGE FILE: ${fileSizeMB} MB > ${(chunkSizeBytes / (1024 * 1024)).toFixed(1)} MB`);
                        console.log(`  -> Creating new chunk. Total chunks: ${totalChunks + 1}`);
                        totalChunks++;
                        tempChunkSize = 0;
                        tempChunkFiles = 0;
                    } else {
                        // Add to current chunk
                        tempChunkSize += file.size;
                        tempChunkFiles++;
                        console.log(`  -> ADDING TO CHUNK: New tempChunkSize: ${(tempChunkSize / (1024 * 1024)).toFixed(2)} MB, Files: ${tempChunkFiles}`);
                    }
                }

                // Add final chunk if there are remaining files
                if (tempChunkSize > 0) {
                    console.log(`\n-> FINAL CHUNK: ${(tempChunkSize / (1024 * 1024)).toFixed(2)} MB remaining`);
                    console.log(`-> Creating final chunk. Total chunks: ${totalChunks + 1}`);
                    totalChunks++;
                }

                console.log(`\n=== FINAL RESULT: ${totalChunks} total chunks ===`);
                return totalChunks;
            }

            // Function to upload files in chunks
            async function uploadFilesInChunks(filesToUpload, relativePathsToUpload, allRelativePaths, totalFiles) {
                // Get progress elements locally
                const progressBar = document.getElementById('checkingProgressBar');
                const progressText = document.getElementById('checkingProgressText');
                const progressMessage = document.getElementById('progressMessage');
                const progressSection = document.getElementById('checkingProgressSection');

                // Show upload progress if there are files to upload
                if (filesToUpload.length > 0) {
                    progressSection.style.display = 'block';
                    progressMessage.textContent = 'Uploading files and creating captures...';
                    progressBar.style.width = '0%';
                    progressText.textContent = '0%';
                }

                // Create AbortController for upload
                const abortController = new AbortController();
                currentAbortController = abortController;

                // Chunk size for file uploads (50 MB per chunk)
                const CHUNK_SIZE_BYTES = 50 * 1024 * 1024; // 50 MB in bytes
                let allResults = {
                    file_upload_status: 'success',
                    saved_files_count: 0,
                    captures: [],
                    errors: [],
                    message: ''
                };

                // Special case: if all files are skipped, send a single request without chunking
                if (filesToUpload.length === 0) {
                    allResults = await handleSkippedFilesUpload(allRelativePaths, abortController);

                } else {
                    // Upload files in chunks based on size (50MB per chunk)
                    let currentChunk = [];
                    let currentChunkPaths = [];
                    let currentChunkSize = 0;
                    let chunkNumber = 1;
                    let filesProcessed = 0;

                    // Calculate total chunks first
                    const totalChunks = calculateTotalChunks(filesToUpload, CHUNK_SIZE_BYTES);

                    console.log('=== ACTUAL CHUNK UPLOAD DEBUG ===');
                    console.log('Starting upload with calculated total chunks:', totalChunks);

                    // Now upload files in chunks
                    for (let i = 0; i < filesToUpload.length; i++) {
                        const file = filesToUpload[i];
                        const filePath = relativePathsToUpload[i];

                        console.log(`\nProcessing file ${i + 1}/${filesToUpload.length}: ${file.name}`);
                        console.log(`  File size: ${(file.size / (1024 * 1024)).toFixed(2)} MB`);
                        console.log(`  Current chunk size: ${(currentChunkSize / (1024 * 1024)).toFixed(2)} MB`);
                        console.log(`  Current chunk number: ${chunkNumber}`);
                        console.log(`  Files in current chunk: ${currentChunk.length}`);

                        // Check if this file would exceed the 50MB limit
                        if (currentChunkSize + file.size > CHUNK_SIZE_BYTES && currentChunk.length > 0) {
                            console.log(`  -> CHUNK FULL: Would exceed ${(CHUNK_SIZE_BYTES / (1024 * 1024)).toFixed(1)} MB limit`);
                            console.log(`  -> Uploading chunk ${chunkNumber}/${totalChunks}`);
                            // Upload current chunk before adding this file
                            await uploadChunk(currentChunk, currentChunkPaths, chunkNumber, totalChunks, filesProcessed, false, allResults, allRelativePaths, totalFiles, CHUNK_SIZE_BYTES);

                            // Reset for next chunk
                            currentChunk = [];
                            currentChunkPaths = [];
                            currentChunkSize = 0;
                            chunkNumber++;
                            console.log(`  -> Reset for next chunk. New chunk number: ${chunkNumber}`);
                        }

                        // Add file to current chunk
                        currentChunk.push(file);
                        currentChunkPaths.push(filePath);
                        currentChunkSize += file.size;
                        filesProcessed++;
                        console.log(`  -> Added to chunk. New chunk size: ${(currentChunkSize / (1024 * 1024)).toFixed(2)} MB`);

                        // Check if this is the last file
                        if (i === filesToUpload.length - 1) {
                            console.log(`  -> LAST FILE: Uploading final chunk ${chunkNumber}/${totalChunks}`);
                            // Upload final chunk
                            await uploadChunk(currentChunk, currentChunkPaths, chunkNumber, totalChunks, filesProcessed, true, allResults, allRelativePaths, totalFiles, CHUNK_SIZE_BYTES);
                        }

                        // Check if cancel was requested
                        if (cancelRequested) {
                            break;
                        }
                    }


                }

                // Check if cancellation was requested during chunk upload
                if (cancelRequested) {
                    // Small delay to ensure UI updates are visible
                    await new Promise(resolve => setTimeout(resolve, 100));
                    throw new Error('Upload cancelled by user');
                }

                // Check if upload was aborted due to errors
                if (allResults.file_upload_status === 'error') {
                    // Clear the reference since upload was aborted
                    currentAbortController = null;
                    // Show error results
                    showUploadResults(allResults, allResults.saved_files_count, totalFiles);
                    return allResults; // Exit early, don't continue with normal flow
                }

                // Clear the reference since upload completed
                currentAbortController = null;

                // Debug logging for final results
                console.log('Final upload results:', allResults);

                return allResults;
            }

            // Helper function to upload a chunk
            async function uploadChunk(chunk, chunkPaths, chunkNum, totalChunks, filesProcessed, isFinalChunk, allResults, allRelativePaths, totalFiles, CHUNK_SIZE_BYTES) {
                console.log(`Uploading chunk ${chunkNum}/${totalChunks}:`, {
                    chunkSize: chunk.length,
                    chunkPaths: chunkPaths,
                    filesProcessed: filesProcessed,
                    isFinalChunk: isFinalChunk,
                    chunkFiles: chunk.map(f => f.webkitRelativePath || f.name)
                });
                // Get progress elements locally
                const progressBar = document.getElementById('checkingProgressBar');
                const progressText = document.getElementById('checkingProgressText');
                const progressMessage = document.getElementById('progressMessage');

                // Update progress
                const progress = Math.round((filesProcessed / totalFiles) * 100);
                progressBar.style.width = progress + '%';
                progressText.textContent = progress + '%';

                if (chunk.length === 1 && chunk[0].size > CHUNK_SIZE_BYTES) {
                    // Large file upload
                    const file = chunk[0];
                    progressMessage.textContent = `Uploading large file: ${file.name} (${(file.size / (1024 * 1024)).toFixed(1)} MB)...`;
                } else {
                    // Normal chunk upload
                    progressMessage.textContent = `Uploading chunk ${chunkNum}/${totalChunks} (${filesProcessed} files processed)...`;
                }

                // Create form data for this chunk
                const chunkFormData = new FormData();

                // Add files for this chunk
                chunk.forEach(file => {
                    chunkFormData.append('files', file);
                });
                chunkPaths.forEach(path => {
                    chunkFormData.append('relative_paths', path);
                });

                // Always add all relative paths for capture creation
                allRelativePaths.forEach(path => {
                    chunkFormData.append('all_relative_paths', path);
                });

                // Add other form fields
                const captureType = document.getElementById('captureTypeSelect').value;
                chunkFormData.append('capture_type', captureType);

                if (captureType === 'drf') {
                    const channels = document.getElementById('captureChannelsInput').value;
                    chunkFormData.append('channels', channels);
                } else if (captureType === 'rh') {
                    const scanGroup = document.getElementById('captureScanGroupInput').value;
                    chunkFormData.append('scan_group', scanGroup);
                }

                // Add chunk information
                chunkFormData.append('is_chunk', 'true');
                chunkFormData.append('chunk_number', chunkNum.toString());
                chunkFormData.append('total_chunks', totalChunks.toString());

                // Check for cancellation before starting this chunk
                if (cancelRequested) {
                    throw new Error('Upload cancelled by user');
                }

                // Upload this chunk with timeout (longer timeout for large files)
                const controller = new AbortController();
                currentAbortController = controller;
                const MIN_AVG_UPLOAD_RATE = 100 * 1024; // 100 KB/s minimum upload rate
                const MIN_TIMEOUT_MS = 30000; // Minimum 30 seconds timeout
                const total_chunk_size_bytes = chunk.reduce((total, file) => total + file.size, 0);
                const calculated_timeout = total_chunk_size_bytes / MIN_AVG_UPLOAD_RATE * 1000;
                const timeout = Math.max(calculated_timeout, MIN_TIMEOUT_MS); // Use at least 30 seconds

                // Debug logging for timeout calculation
                console.log(`Chunk ${chunkNum} timeout calculation:`, {
                    total_chunk_size_bytes: total_chunk_size_bytes,
                    total_chunk_size_mb: (total_chunk_size_bytes / (1024 * 1024)).toFixed(2),
                    min_upload_rate_kbps: MIN_AVG_UPLOAD_RATE / 1024,
                    calculated_timeout_ms: calculated_timeout,
                    calculated_timeout_minutes: (calculated_timeout / (1000 * 60)).toFixed(2),
                    final_timeout_ms: timeout,
                    final_timeout_minutes: (timeout / (1000 * 60)).toFixed(2),
                    using_minimum: calculated_timeout < MIN_TIMEOUT_MS
                });

                const timeoutId = setTimeout(() => controller.abort(), timeout);

                let response;
                let chunkResult;

                try {
                    response = await fetch("{% url 'users:upload_capture' %}", {
                        method: 'POST',
                        body: chunkFormData,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    chunkResult = await response.json();

                    // Debug logging for large files
                    if (chunk.length === 1 && chunk[0].size > CHUNK_SIZE_BYTES) {
                        console.log('Large file upload result:', {
                            isFinalChunk,
                            chunkResult,
                            captures: chunkResult.captures,
                            message: chunkResult.message
                        });
                    }

                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error('Upload timeout - connection may be lost');
                    }
                    throw error;
                }

                // Merge results
                if (chunkResult.saved_files_count !== undefined) {
                    allResults.saved_files_count += chunkResult.saved_files_count;
                }
                // Collect captures from the final chunk
                if (chunkResult.captures && isFinalChunk) {
                    console.log(`Chunk ${chunkNum} (final): Collecting captures:`, {
                        chunkCaptures: chunkResult.captures,
                        allResultsCapturesBefore: allResults.captures,
                        isFinalChunk: isFinalChunk
                    });
                    allResults.captures = allResults.captures.concat(chunkResult.captures);
                    console.log(`Chunk ${chunkNum} (final): allResults.captures after:`, allResults.captures);
                } else if (chunkResult.captures && !isFinalChunk) {
                    console.log(`Chunk ${chunkNum} (non-final): Skipping captures (not final chunk):`, chunkResult.captures);
                }
                // Also collect any message from the final chunk
                if (chunkResult.message && isFinalChunk) {
                    allResults.message = chunkResult.message;
                }
                if (chunkResult.errors) {
                    allResults.errors = allResults.errors.concat(chunkResult.errors);
                }

                // Check if any chunk failed
                if (chunkResult.file_upload_status === 'error') {
                    allResults.file_upload_status = 'error';
                    allResults.message = chunkResult.message || 'Upload failed';
                    const progressMessage = document.getElementById('progressMessage');
                    if (progressMessage) {
                        progressMessage.textContent = 'Upload aborted due to errors. Please check the results.';
                    }
                    throw new Error('Upload failed: ' + chunkResult.message);
                } else if (chunkResult.file_upload_status === 'success') {
                    // Only update to success if this is the final chunk
                    if (isFinalChunk) {
                        allResults.file_upload_status = 'success';
                    }
                }
            }

            document.getElementById('uploadCaptureForm').addEventListener('submit', async function(e) {
                e.preventDefault();

                // Set processing state
                isProcessing = true;
                uploadInProgress = true;
                cancelRequested = false; // Reset cancel flag for new upload
                sessionStorage.setItem('uploadInProgress', 'true');

                // Check if files are selected
                if (!window.selectedFiles || window.selectedFiles.length === 0) {
                    alert('Please select files to upload.');
                    return;
                }

                const files = window.selectedFiles;

                // Check for large files before duplicate checking
                if (checkForLargeFiles(files, cancelButton, submitButton)) {
                    return;
                }

                // Check files for duplicates
                await checkFilesForDuplicates(files, cancelButton, submitButton);

                // Prepare files for upload (only non-skipped files)
                const filesToUpload = [];
                const relativePathsToUpload = [];

                // Always collect all relative paths for capture creation, even for skipped files
                const allRelativePaths = [];

                let skippedFilesCount = 0;

                for (const file of files) {
                    let directory = "/";
                    if (file.webkitRelativePath) {
                        const pathParts = file.webkitRelativePath.split('/');
                        if (pathParts.length > 1) {
                            pathParts.pop();
                            directory = "/" + pathParts.join("/");
                        }
                    }
                    const fileKey = `${directory}/${file.name}`;
                    const relativePath = file.webkitRelativePath || file.name;

                    // Add to all paths for capture creation
                    allRelativePaths.push(relativePath);

                    // Only add to upload list if not skipped
                    if (!window.filesToSkip.has(fileKey)) {
                        filesToUpload.push(file);
                        relativePathsToUpload.push(relativePath);
                    } else {
                        skippedFilesCount++;
                    }
                }

                // Debug logging for file structure
                console.log('Files to upload structure:', {
                    totalFiles: filesToUpload.length,
                    skippedFiles: skippedFilesCount,
                    totalSelectedFiles: files.length,
                    files: filesToUpload.map(f => ({
                        name: f.name,
                        path: f.webkitRelativePath || f.name,
                        size: f.size,
                        sizeMB: (f.size / (1024 * 1024)).toFixed(2)
                    }))
                });

                // Upload files in chunks
                try {
                    const uploadResults = await uploadFilesInChunks(filesToUpload, relativePathsToUpload, allRelativePaths, filesToUpload.length);

                    // Clear the reference since upload completed
                    currentAbortController = null;

                    // Debug logging for final results
                    console.log('Final upload results:', {
                        ...uploadResults,
                        capturesLength: uploadResults.captures ? uploadResults.captures.length : 0
                    });

                    // Show results
                    showUploadResults(uploadResults, uploadResults.saved_files_count, files.length, skippedFilesCount);

                    // Don't auto-reload for successful uploads - let user close modal first
                } catch (error) {
                    if (cancelRequested) {
                        // Check if this was cancelled during duplicate checking (no files uploaded yet)
                        if (!uploadInProgress) {
                            // Already showed alert in checkFilesForDuplicates function
                            // No need to reload since no files were uploaded
                        } else {
                            alert('Upload cancelled. Any files uploaded before cancellation have been saved.');
                            // Reload page after cancellation
                            setTimeout(() => {
                                window.location.reload();
                            }, 1000);
                        }
                    } else if (error.name === 'AbortError') {
                        alert('Upload was interrupted. Any files uploaded before the interruption have been saved.');
                        // Reload page after interruption
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        // Don't show alert for network errors after page refresh
                        if (uploadInProgress || sessionStorage.getItem('uploadInProgress')) {
                            // Suppressing network error alert during active upload
                        } else {
                            alert('Network error during upload. Please check your connection and try again.');
                        }
                    } else {
                        alert('Upload failed: ' + error.message);
                        // Reload page after other errors
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    }
                } finally {
                    // Clean up UI state - ensure this always runs
                    resetUIState();
                }
            });

            // Function to reset UI state
            function resetUIState() {

                // Reset submit button
                submitButton.disabled = false;

                // Hide progress section
                const progressSection = document.getElementById('checkingProgressSection');
                if (progressSection) {
                    progressSection.style.display = 'none';
                }

                // Reset cancel button
                cancelButton.textContent = 'Cancel';
                cancelButton.classList.remove('btn-warning');
                cancelButton.disabled = false;

                // Reset close button
                if (closeButton) {
                    closeButton.disabled = false;
                    closeButton.style.opacity = '1';
                }

                // Reset progress elements
                const progressBar = document.getElementById('checkingProgressBar');
                const progressText = document.getElementById('checkingProgressText');
                const progressMessage = document.getElementById('progressMessage');

                if (progressBar) progressBar.style.width = '0%';
                if (progressText) progressText.textContent = '0%';
                if (progressMessage) progressMessage.textContent = '';

                // Reset state flags
                isProcessing = false;
                uploadInProgress = false;
                cancelRequested = false;

                // Clear session storage
                sessionStorage.removeItem('uploadInProgress');

                // Clear abort controller
                currentAbortController = null;
            }

            // Function to show upload results
            function showUploadResults(result, uploadedCount, totalCount, skippedCount = 0) {
                // Debug logging
                console.log('showUploadResults called with:', {
                    result,
                    uploadedCount,
                    totalCount,
                    hasMessage: !!result.message,
                    message: result.message,
                    captures: result.captures,
                    capturesLength: result.captures ? result.captures.length : 0
                });

                // Check if page was refreshed during upload
                if (!uploadInProgress && result.file_upload_status === 'error') {
                    resetUIState(); // Ensure UI is reset even if modal is not shown
                    return;
                }

                let modalBody = document.getElementById('uploadResultModalBody');
                let resultModalEl = document.getElementById('uploadResultModal');
                let modal = new bootstrap.Modal(resultModalEl);

                // Close the upload modal before showing result modal
                const uploadModal = bootstrap.Modal.getInstance(document.getElementById('uploadCaptureModal'));
                if (uploadModal) {
                    uploadModal.hide();
                }

                let msg = '';
                if (result.file_upload_status === 'success') {
                    // Use frontend accumulated count for accuracy, but include backend message for additional info
                    if (uploadedCount === 0 && totalCount > 0) {
                        // All files were skipped
                        msg = `<b>Upload complete!</b><br />All ${totalCount} files already existed on the server.`;
                    } else if (skippedCount > 0) {
                        // Some files were uploaded, some were skipped
                        msg = `<b>Upload complete!</b><br />Files uploaded: <strong>${uploadedCount}</strong> / ${totalCount}`;
                        msg += `<br />Files already exist: <strong>${skippedCount}</strong>`;
                    } else {
                        // All files were uploaded (no skipped files)
                        msg = `<b>Upload complete!</b><br />Files uploaded: <strong>${uploadedCount}</strong> / ${totalCount}`;
                    }

                    if (result.captures && result.captures.length > 0) {
                        console.log('Displaying captures in modal:', {
                            captures: result.captures,
                            capturesLength: result.captures.length
                        });
                        let uuids = result.captures.map(uuid => `<li>${uuid}</li>`).join('');
                        msg += `<br />Created capture UUID(s):<ul>${uuids}</ul>`;
                    } else {
                        console.log('No captures to display:', {
                            hasCaptures: !!result.captures,
                            capturesLength: result.captures ? result.captures.length : 0
                        });
                    }
                    if (result.errors && result.errors.length > 0) {
                        let errs = result.errors.map(e => `<li>${e}</li>`).join('');
                        msg += `<br /><b>Errors:</b><ul>${errs}</ul>`;
                        msg += `<br /><b>Please check details and upload again.</b>`;
                    }
                } else {
                    // Upload failed - show error message and prompt to remove error files
                    msg = '<b>Upload Failed</b><br />';
                    if (result.message) {
                        msg += `${result.message}<br /><br />`;
                    }
                    msg += '<b>Please check file validity and try again.</b>';

                    if (result.errors && result.errors.length > 0) {
                        let errs = result.errors.map(e => `<li>${e}</li>`).join('');
                        msg += `<br /><br /><b>Error Details:</b><ul>${errs}</ul>`;
                    }
                }
                modalBody.innerHTML = msg;
                modal.show();

                // Add event listener to reload page when result modal is closed (only for successful uploads)
                if (result.file_upload_status === 'success') {
                    resultModalEl.addEventListener('hidden.bs.modal', function() {
                        window.location.reload();
                    }, {
                        once: true
                    }); // Only trigger once per modal instance
                }
            }
        });
    </script>
    <!-- Capture Type Selection JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const captureTypeSelect = document.getElementById('captureTypeSelect');
            const channelInputGroup = document.getElementById('channelInputGroup');
            const scanGroupInputGroup = document.getElementById('scanGroupInputGroup');
            const captureChannelsInput = document.getElementById('captureChannelsInput');
            const captureScanGroupInput = document.getElementById('captureScanGroupInput');

            if (captureTypeSelect) {
                captureTypeSelect.addEventListener('change', function() {
                    const selectedType = this.value;

                    // Hide both input groups initially
                    if (channelInputGroup) channelInputGroup.classList.add('hidden-input-group');
                    if (scanGroupInputGroup) scanGroupInputGroup.classList.add('hidden-input-group');

                    // Clear required attributes
                    if (captureChannelsInput) captureChannelsInput.removeAttribute('required');
                    if (captureScanGroupInput) captureScanGroupInput.removeAttribute('required');

                    // Show appropriate input group based on selection
                    if (selectedType === 'drf') {
                        if (channelInputGroup) channelInputGroup.classList.remove('hidden-input-group');
                        if (captureChannelsInput) captureChannelsInput.setAttribute('required', 'required');
                    } else if (selectedType === 'rh') {
                        if (scanGroupInputGroup) scanGroupInputGroup.classList.remove('hidden-input-group');
                        // scan_group is optional for RadioHound captures
                    }
                });
            }

            // Reset form when modal is hidden
            const uploadModal = document.getElementById('uploadCaptureModal');
            if (uploadModal) {
                uploadModal.addEventListener('hidden.bs.modal', function() {
                    // Reset the form
                    const form = document.getElementById('uploadCaptureForm');
                    if (form) {
                        form.reset();
                    }

                    // Hide input groups
                    if (channelInputGroup) channelInputGroup.classList.add('hidden-input-group');
                    if (scanGroupInputGroup) scanGroupInputGroup.classList.add('hidden-input-group');

                    // Clear required attributes
                    if (captureChannelsInput) captureChannelsInput.removeAttribute('required');
                    if (captureScanGroupInput) captureScanGroupInput.removeAttribute('required');

                    // Clear file check status
                    const checkStatusDiv = document.getElementById('fileCheckStatus');
                    if (checkStatusDiv) {
                        checkStatusDiv.style.display = 'none';
                    }

                    // Clear status alerts and file details button
                    const uploadModalBody = document.querySelector('#uploadCaptureModal .modal-body');
                    const existingAlerts = uploadModalBody.querySelectorAll('.alert.alert-warning, .alert.alert-success');
                    existingAlerts.forEach(alert => {
                        if (alert.textContent.includes('will be skipped') || alert.textContent.includes('will be uploaded')) {
                            alert.remove();
                        }
                    });

                    // Remove file details button
                    const detailsLink = uploadModalBody.querySelector('#viewFileDetailsLink');
                    if (detailsLink) {
                        detailsLink.parentNode.remove();
                    }

                    // Clear global variables
                    window.filesToSkip.clear();
                    window.fileCheckResults.clear();
                });
            }
        });
    </script>
    <!-- This code calculates BLAKE3 hashes in the browser for file deduplication -->
    <!-- Load the WASM library first -->
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4.12.0/dist/blake3.umd.min.js"></script>
    <script>
        // Global variable to track files that should be skipped
        window.filesToSkip = new Set();
        window.fileCheckResults = new Map(); // Store detailed results for each file

        document.addEventListener('DOMContentLoaded', function() {
            var modal = document.getElementById('uploadCaptureModal');
            if (!modal) {
                console.warn('uploadCaptureModal not found');
                return;
            }
            modal.addEventListener('shown.bs.modal', function() {
                var fileInput = document.getElementById('captureFileInput');
                if (!fileInput) {
                    console.warn('captureFileInput not found');
                    return;
                }
                // Remove any previous handler to avoid duplicates
                fileInput.removeEventListener('change', window._blake3CaptureHandler);

                // Simple file handler that just stores the selected files
                window._blake3CaptureHandler = async function(event) {
                    const files = event.target.files;
                    if (!files || files.length === 0) {
                        return;
                    }

                    // Store the selected files for later processing
                    window.selectedFiles = Array.from(files);
                };
                fileInput.addEventListener('change', window._blake3CaptureHandler);
            });
        });

        // Remove old file checking functions - no longer needed
        // The checking is now done during upload with progress bar
    </script>
{% endblock javascript %}
