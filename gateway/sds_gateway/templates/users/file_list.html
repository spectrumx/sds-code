{# templates/users/file_list.html #}
{% extends "base.html" %}

{% load static %}

{% block bodyclass %}
    hero-white-page
{% endblock bodyclass %}
{% block body %}
    <!-- Add Font Awesome for sort arrows -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <!-- Add noUiSlider CSS first -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" />
    <!-- Add file-list.css for upload modal styling -->
    <link rel="stylesheet" href="{% static 'css/file-list.css' %}" />
    <!-- Add noUiSlider JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
    <style>
        .clear-search-hidden {
            display: none;
        }
    </style>
    <!-- CSRF Token for JavaScript -->
    {% csrf_token %}
    <!-- System-wide notifications -->
    {% if system_notifications %}
        <div class="container">
            {% for notification in system_notifications %}
                <div class="alert alert-dismissible alert-{{ notification.level }}">{{ notification.user_message }}</div>
            {% endfor %}
        </div>
    {% endif %}
    {% if messages %}
        <div class="container">
            {% for message in messages %}
                <div class="alert alert-dismissible {% if message.tags %}alert-{{ message.tags }}{% endif %}">
                    {{ message }}
                    <button type="button"
                            class="btn-close"
                            data-bs-dismiss="alert"
                            aria-label="Close"></button>
                </div>
            {% endfor %}
        </div>
    {% endif %}
    <div id="upload-alert-container" class="container mt-3"></div>
    <div class="container-fluid px-5 pt-4">
        <!-- Headers Row -->
        <div class="row mb-1">
            <div class="col-12">
                <h1 class="mb-0 text-start">Captures</h1>
            </div>
        </div>
        <!-- Content Row -->
        <div class="row">
            <!-- Sidebar Filters -->
            <aside class="col-md-3 mb-4">
                <div class="sidebar-filters">
                    <div class="accordion" id="filtersAccordion">
                        <!-- Frequency -->
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="headingFrequency">
                                <button class="accordion-button collapsed"
                                        type="button"
                                        data-bs-target="#collapseFrequency"
                                        aria-expanded="false"
                                        aria-controls="collapseFrequency">
                                    <i class="fas fa-signal me-2"></i>
                                    Center Frequency
                                </button>
                            </h2>
                            <div id="collapseFrequency" class="accordion-collapse collapse">
                                <div class="accordion-body">
                                    <label for="frequency-range" class="form-label">Center Frequency Range</label>
                                    <div id="frequency-range-slider"
                                         class="mt-3 mb-3"
                                         role="slider"
                                         aria-valuemin="0"
                                         aria-valuemax="10"
                                         aria-valuenow="0,10"
                                         aria-valuetext="Frequency range from 0.0 GHz to 10.0 GHz"></div>
                                    <div class="d-flex justify-content-between mb-3">
                                        <span id="frequency-range-lower" aria-live="polite">0 GHz</span>
                                        <span id="frequency-range-upper" aria-live="polite">10 GHz</span>
                                    </div>
                                    <div class="row mt-3">
                                        <div class="col-6">
                                            <label for="centerFreqMinInput" class="form-label small">Min (GHz)</label>
                                            <input type="number"
                                                   id="centerFreqMinInput"
                                                   class="form-control form-control-sm"
                                                   min="0"
                                                   max="10"
                                                   step="0.1"
                                                   value="0"
                                                   placeholder="0" />
                                        </div>
                                        <div class="col-6">
                                            <label for="centerFreqMaxInput" class="form-label small">Max (GHz)</label>
                                            <input type="number"
                                                   id="centerFreqMaxInput"
                                                   class="form-control form-control-sm"
                                                   min="0"
                                                   max="10"
                                                   step="0.1"
                                                   value="10"
                                                   placeholder="10" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Date -->
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="headingDate">
                                <button class="accordion-button collapsed"
                                        type="button"
                                        data-bs-target="#collapseDate"
                                        aria-expanded="false"
                                        aria-controls="collapseDate">
                                    <i class="fas fa-calendar me-2"></i>
                                    Date Range
                                </button>
                            </h2>
                            <div id="collapseDate" class="accordion-collapse collapse">
                                <div class="accordion-body">
                                    <div class="row">
                                        <div class="col mb-3">
                                            <label class="form-label" for="start_date">Start Date</label>
                                            <input type="date" class="form-control" id="start_date" name="date_start" />
                                        </div>
                                        <div class="col">
                                            <label class="form-label" for="end_date">End Date</label>
                                            <input type="date" class="form-control" id="end_date" name="date_end" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Receiver -->
                        <!--
          <div class="accordion-item mb-2">
            <h2 class="accordion-header" id="headingReceiver">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseReceiver" aria-expanded="false" aria-controls="collapseReceiver">
                Receiver
              </button>
            </h2>
            <div id="collapseReceiver" class="accordion-collapse collapse" aria-labelledby="headingReceiver" data-bs-parent="#filtersAccordion">
              <div class="accordion-body">
                <select class="form-select" id="receiverSelect">
                  <option value="">Select Receiver</option>
                  <option value="receiver1">Receiver 1</option>
                  <option value="receiver2">Receiver 2</option>
                  <option value="receiver3">Receiver 3</option>
                </select>
              </div>
            </div>
          </div>
-->
                        <!-- Category -->
                        <!--
          <div class="accordion-item">
            <h2 class="accordion-header" id="headingCategory">
              <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCategory" aria-expanded="false" aria-controls="collapseCategory">
                [Category]
              </button>
            </h2>
            <div id="collapseCategory" class="accordion-collapse collapse" aria-labelledby="headingCategory" data-bs-parent="#filtersAccordion">
              <div class="accordion-body">
                <select class="form-select" id="categorySelect">
                  <option value="">Select Category</option>
                  <option value="category1">Category 1</option>
                  <option value="category2">Category 2</option>
                  <option value="category3">Category 3</option>
                </select>
              </div>
            </div>
          </div>
          -->
                    </div>
                    <div class="d-flex gap-3 mt-4">
                        <button class="btn btn-primary flex-fill"
                                type="button"
                                id="apply-filters-btn">Apply Filters</button>
                        <button class="btn btn-secondary flex-fill"
                                type="button"
                                id="clear-filters-btn">Clear Filters</button>
                    </div>
                </div>
            </aside>
            <!-- Main Content -->
            <main class="col-md-9 pt-0">
                <!-- Search Form -->
                <form id="search-form"
                      role="search"
                      aria-label="Search captures"
                      class="text-start mt-0">
                    <div class="row g-3 mb-3">
                        <div class="col-12">
                            <label for="search-input" class="visually-hidden">Search captures</label>
                            <div class="input-group">
                                <div class="position-relative flex-grow-1">
                                    <input type="search"
                                           class="form-control pe-5"
                                           id="search-input"
                                           placeholder="Search captures..."
                                           value="{{ search }}"
                                           aria-describedby="searchHelp" />
                                    <button type="button"
                                            class="btn btn-link position-absolute end-0 top-50 translate-middle-y text-secondary px-3 clear-search-hidden"
                                            id="clear-search-btn"
                                            aria-label="Clear search">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                                <button class="btn btn-primary"
                                        type="submit"
                                        id="search-btn"
                                        aria-label="Search captures">
                                    <i class="fas fa-search" aria-hidden="true"></i>
                                    <span class="d-none d-sm-inline ms-1">Search</span>
                                </button>
                                <button type="button"
                                        class="btn btn-success"
                                        data-bs-toggle="modal"
                                        data-bs-target="#uploadCaptureModal">
                                    <i class="fas fa-upload"></i> Upload Capture
                                </button>
                            </div>
                        </div>
                    </div>
                </form>
                <!-- Loading indicator -->
                <div id="loading-indicator" class="text-center py-3 d-none">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2 text-muted">Searching captures...</p>
                </div>
                <!-- Upload Capture Modal -->
                <div class="modal fade"
                     id="uploadCaptureModal"
                     tabindex="-1"
                     aria-labelledby="uploadCaptureModalLabel"
                     aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <form id="uploadCaptureForm" enctype="multipart/form-data">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="uploadCaptureModalLabel">Upload Files & Create Capture</h5>
                                    <button type="button"
                                            class="btn-close"
                                            data-bs-dismiss="modal"
                                            aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <!-- Progress Bar Section (initially hidden) -->
                                    <div id="checkingProgressSection" class="mt-3 progress-section-hidden">
                                        <div class="d-flex align-items-center">
                                            <div class="spinner-border spinner-border-sm me-2" role="status">
                                                <span class="visually-hidden">Processing...</span>
                                            </div>
                                            <div class="flex-grow-1">
                                                <div class="progress progress-bar-custom">
                                                    <div id="checkingProgressBar"
                                                         class="progress-bar"
                                                         role="progressbar"
                                                         class="progress-bar progress-bar-width-0"></div>
                                                </div>
                                            </div>
                                            <small class="ms-2 text-muted" id="checkingProgressText">0%</small>
                                        </div>
                                        <small class="text-muted" id="progressMessage">Checking files for duplicates...</small>
                                    </div>
                                    <!-- File Selection Section -->
                                    <label for="captureFileInput" class="form-label">Select a folder to upload</label>
                                    <input type="file"
                                           id="captureFileInput"
                                           name="files"
                                           multiple
                                           webkitdirectory
                                           directory
                                           class="form-control" />
                                    <!-- Capture Type Selection -->
                                    <div class="mt-3">
                                        <label for="captureTypeSelect" class="form-label">Capture Type</label>
                                        <select id="captureTypeSelect"
                                                name="capture_type"
                                                class="form-select"
                                                required>
                                            <option value="">Select capture type...</option>
                                            <option value="drf">DigitalRF</option>
                                            <option value="rh">RadioHound</option>
                                        </select>
                                        <div class="form-text">
                                            <strong>DigitalRF:</strong> For .h5/.hdf5 files with channel-based structure
                                            <br />
                                            <strong>RadioHound:</strong> For .rh.json files with scan group metadata
                                        </div>
                                    </div>
                                    <!-- Channel Input (shown for DigitalRF) -->
                                    <div id="channelInputGroup" class="mt-3 hidden-input-group">
                                        <label for="captureChannelsInput" class="form-label">Capture Channel Names (comma-separated)</label>
                                        <input type="text"
                                               id="captureChannelsInput"
                                               name="channels"
                                               class="form-control"
                                               placeholder="e.g. ch1,ch2,ch3" />
                                        <div class="form-text">Required for DigitalRF captures</div>
                                    </div>
                                    <!-- Scan Group Input (shown for RadioHound) -->
                                    <div id="scanGroupInputGroup" class="mt-3 hidden-input-group">
                                        <label for="captureScanGroupInput" class="form-label">Scan Group</label>
                                        <input type="text"
                                               id="captureScanGroupInput"
                                               name="scan_group"
                                               class="form-control"
                                               placeholder="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" />
                                        <div class="form-text">For RadioHound captures, optional UUID</div>
                                    </div>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                    <button type="submit" class="btn btn-primary" id="uploadSubmitBtn">
                                        <span class="upload-text">Check & Upload Files</span>
                                        <span class="upload-spinner d-none">
                                            <span class="spinner-border spinner-border-sm"
                                                  role="status"
                                                  aria-hidden="true"></span>
                                            Uploading...
                                        </span>
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
                <!-- Upload Result Modal -->
                <div class="modal fade"
                     id="uploadResultModal"
                     tabindex="-1"
                     aria-labelledby="uploadResultModalLabel"
                     aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="uploadResultModalLabel">Upload Result</h5>
                                <button type="button"
                                        class="btn-close"
                                        data-bs-dismiss="modal"
                                        aria-label="Close"></button>
                            </div>
                            <div class="modal-body" id="uploadResultModalBody">
                                <!-- Content will be set by JS -->
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Captures Table -->
                {% include "users/partials/captures_page_table.html" %}
            </main>
        </div>
    </div>
    <!-- Capture Details Modal -->
    {% include "users/partials/capture_modal.html" %}
{% endblock body %}
{% block javascript %}
    {{ block.super }}
    <script src="{% static 'js/components.js' %}"></script>
    <script src="{% static 'js/file-list.js' %}"></script>
    <script src="{% static 'js/userSearchComponent.js' %}"></script>
    <script>
        // Initialize noUiSlider for frequency range
        document.addEventListener('DOMContentLoaded', function() {
            const frequencyRangeSlider = document.getElementById('frequency-range-slider');
            if (frequencyRangeSlider) {
                noUiSlider.create(frequencyRangeSlider, {
                    start: [0, 10],
                    connect: true,
                    range: {
                        'min': 0,
                        'max': 10
                    },
                    step: 0.1,
                    format: {
                        to: function(value) {
                            return parseFloat(value).toFixed(1);
                        },
                        from: function(value) {
                            return parseFloat(value);
                        }
                    }
                });

                const lowerValue = document.getElementById('frequency-range-lower');
                const upperValue = document.getElementById('frequency-range-upper');
                const minInput = document.getElementById('centerFreqMinInput');
                const maxInput = document.getElementById('centerFreqMaxInput');

                // Track user interaction with slider
                let userInteractedWithSlider = false;

                frequencyRangeSlider.noUiSlider.on('update', function(values, handle) {
                    const value = parseFloat(values[handle]);
                    if (handle === 0) {
                        lowerValue.textContent = value + ' GHz';
                        minInput.value = value;
                        frequencyRangeSlider.setAttribute('aria-valuetext', `Frequency range from ${value} GHz to ${parseFloat(values[1])} GHz`);
                    } else {
                        upperValue.textContent = value + ' GHz';
                        maxInput.value = value;
                        frequencyRangeSlider.setAttribute('aria-valuetext', `Frequency range from ${parseFloat(values[0])} GHz to ${value} GHz`);
                    }
                });

                // Mark as interacted when user changes slider
                frequencyRangeSlider.noUiSlider.on('change', function() {
                    userInteractedWithSlider = true;
                    // Trigger the global tracking
                    if (window.initializeFrequencySlider) {
                        // Update the global interaction tracking
                        const event = new Event('change');
                        minInput.dispatchEvent(event);
                    }
                });

                // Update slider when input values change
                minInput.addEventListener('change', function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 10) {
                        frequencyRangeSlider.noUiSlider.set([value, null]);
                    }
                });

                maxInput.addEventListener('change', function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 10) {
                        frequencyRangeSlider.noUiSlider.set([null, value]);
                    }
                });

                // Initialize from URL parameters after slider is created
                if (window.initializeFrequencySlider) {
                    window.initializeFrequencySlider();
                }
            }
        });

        // Initialize share modals for captures
        document.addEventListener('DOMContentLoaded', function() {
            // Create a UserSearchHandler for each share modal
            document.querySelectorAll('.modal[data-item-uuid]').forEach(modal => {
                const itemUuid = modal.getAttribute('data-item-uuid');
                const itemType = modal.getAttribute('data-item-type');
                if (window.UserSearchHandler) {
                    const handler = new window.UserSearchHandler();
                    // Store the handler on the modal element
                    modal.userSearchHandler = handler;
                }

                // On modal show, set the item info and call init()
                modal.addEventListener('show.bs.modal', function() {
                    if (modal.userSearchHandler) {
                        modal.userSearchHandler.setItemInfo(itemUuid, itemType);
                        modal.userSearchHandler.init();
                    }
                });

                // On modal hide, reset all selections and entered data
                modal.addEventListener('hidden.bs.modal', function() {
                    if (modal.userSearchHandler) {
                        modal.userSearchHandler.resetAll();
                    }
                });
            });

            // Check for download alert messages
            const downloadAlert = sessionStorage.getItem('captureDownloadAlert');
            if (downloadAlert) {
                const alertData = JSON.parse(downloadAlert);
                showAlert(alertData.message, alertData.type);
                sessionStorage.removeItem('captureDownloadAlert');
            }
        });

        // Function to show alerts (same as in dataset-list.js)
        function showAlert(message, type) {
            const alertClass = type === "success" ? "alert-success" : "alert-danger";
            const alertHtml = `
                <div class="alert ${alertClass} alert-dismissible fade show" role="alert">
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            `;

            const alertContainer = document.querySelector(".container-fluid");
            if (alertContainer) {
                alertContainer.insertAdjacentHTML("afterbegin", alertHtml);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Upload Capture Modal JS

            let isProcessing = false; // Flag to track if processing is active

            // Reset cancellation state on page load

            // Add page refresh/close confirmation
            let uploadInProgress = false;

            // Clear any existing result modals on page load
            const existingResultModal = document.getElementById('uploadResultModal');
            if (existingResultModal) {
                const modalInstance = bootstrap.Modal.getInstance(existingResultModal);
                if (modalInstance) {
                    modalInstance.hide();
                }
            }

            // Clear any upload-related session storage
            if (sessionStorage.getItem('uploadInProgress')) {
                sessionStorage.removeItem('uploadInProgress');
            }

            // Handle beforeunload event (page refresh/close)
            window.addEventListener('beforeunload', function(e) {
                if (uploadInProgress || sessionStorage.getItem('uploadInProgress')) {
                    e.preventDefault();
                    e.returnValue = 'Upload in progress will be aborted. Are you sure you want to leave?';
                    return e.returnValue;
                }
            });

            // Handle visibility change (tab close/minimize)
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'hidden' && uploadInProgress) {
                    // Page hidden during upload
                }
            });

            // Get button references
            const cancelButton = document.querySelector('#uploadCaptureModal .btn-secondary');
            const submitButton = document.getElementById('uploadSubmitBtn');

            // Store abort controller reference for cancellation
            let currentAbortController = null;

            // Reset cancellation state when modal is opened
            document.getElementById('uploadCaptureModal').addEventListener('show.bs.modal', function() {
                isProcessing = false;
                currentAbortController = null;
            });

            // Reset cancellation state when files are selected
            document.getElementById('captureFileInput').addEventListener('change', function() {

                isProcessing = false;
                currentAbortController = null;
            });

            // Reset cancellation state when modal is hidden
            document.getElementById('uploadCaptureModal').addEventListener('hidden.bs.modal', function() {
                isProcessing = false;
                currentAbortController = null;
            });

            // Handle cancel button click
            let cancelRequested = false;

            cancelButton.addEventListener('click', function() {
                if (isProcessing) {
                    // Cancel processing
                    cancelRequested = true;

                    // Abort current upload if controller exists
                    if (currentAbortController) {
                        currentAbortController.abort();
                    }

                    // Update UI immediately
                    cancelButton.textContent = 'Cancelling...';
                    cancelButton.disabled = true;

                    // Update progress message
                    const progressMessage = document.getElementById('progressMessage');
                    if (progressMessage) {
                        progressMessage.textContent = 'Cancelling upload...';
                    }

                    // Force UI reset after a short delay to ensure it happens
                    setTimeout(() => {
                        if (cancelRequested) {
                            resetUIState();
                        }
                    }, 500);
                } else {
                    // Normal cancel (no processing active)
                }
            });

            document.getElementById('uploadCaptureForm').addEventListener('submit', async function(e) {
                e.preventDefault();

                // Set processing state
                isProcessing = true;
                uploadInProgress = true;
                cancelRequested = false; // Reset cancel flag for new upload
                sessionStorage.setItem('uploadInProgress', 'true');



                // Check if files are selected
                if (!window.selectedFiles || window.selectedFiles.length === 0) {
                    alert('Please select files to upload.');
                    return;
                }

                // Show progress section
                const progressSection = document.getElementById('checkingProgressSection');
                const progressBar = document.getElementById('checkingProgressBar');
                const progressText = document.getElementById('checkingProgressText');
                const progressMessage = document.getElementById('progressMessage');

                progressSection.style.display = 'block';
                progressMessage.textContent = 'Checking files for duplicates...';

                // Update UI to show processing state
                cancelButton.textContent = 'Cancel Processing';
                cancelButton.classList.add('btn-warning');
                submitButton.disabled = true;

                // Initialize variables for file checking
                window.filesToSkip = new Set();
                window.fileCheckResults = new Map();
                const files = window.selectedFiles;
                const totalFiles = files.length;

                // Check each file for duplicates with progress
                for (let i = 0; i < files.length; i++) {

                    const file = files[i];

                    // Update progress
                    const progress = Math.round(((i + 1) / totalFiles) * 100);
                    progressBar.style.width = progress + '%';
                    progressText.textContent = progress + '%';

                    // Calculate BLAKE3 hash
                    const buffer = await file.arrayBuffer();
                    const hasher = await hashwasm.createBLAKE3();
                    hasher.init();
                    hasher.update(new Uint8Array(buffer));
                    const hashHex = hasher.digest('hex');

                    // Calculate directory path
                    let directory = "/";
                    if (file.webkitRelativePath) {
                        const pathParts = file.webkitRelativePath.split('/');
                        if (pathParts.length > 1) {
                            pathParts.pop();
                            directory = "/" + pathParts.join("/");
                        }
                    }

                    // Check if file exists
                    const checkData = {
                        directory: directory,
                        filename: file.name,
                        checksum: hashHex
                    };

                    try {
                        const response = await fetch("{% url 'users:check_file_exists' %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify(checkData)
                        });
                        const data = await response.json();

                        // Store the result
                        const fileKey = `${directory}/${file.name}`;
                        window.fileCheckResults.set(fileKey, {
                            file: file,
                            directory: directory,
                            filename: file.name,
                            checksum: hashHex,
                            data: data.data
                        });

                        // Mark for skipping if file exists in tree
                        if (data.data && data.data.file_exists_in_tree === true) {
                            window.filesToSkip.add(fileKey);
                        }
                    } catch (error) {
                        // Error checking file
                    }

                    // Check for cancellation after each file check
                    if (cancelRequested) {
                        // Break out of the loop instead of throwing
                        break;
                    }

                }

                // Check if cancellation was requested during file checking
                if (cancelRequested) {
                    // Small delay to ensure UI updates are visible
                    await new Promise(resolve => setTimeout(resolve, 100));
                    throw new Error('Upload cancelled by user');
                }

                // Update progress message for upload phase
                progressMessage.textContent = 'Uploading files and creating captures...';
                progressBar.style.width = '0%';
                progressText.textContent = '0%';

                // Hide progress section
                progressSection.style.display = 'none';

                // Prepare files for upload (only non-skipped files)
                const filesToUpload = [];
                const relativePathsToUpload = [];

                // Always collect all relative paths for capture creation, even for skipped files
                const allRelativePaths = [];

                for (const file of files) {
                    let directory = "/";
                    if (file.webkitRelativePath) {
                        const pathParts = file.webkitRelativePath.split('/');
                        if (pathParts.length > 1) {
                            pathParts.pop();
                            directory = "/" + pathParts.join("/");
                        }
                    }
                    const fileKey = `${directory}/${file.name}`;
                    const relativePath = file.webkitRelativePath || file.name;

                    // Add to all paths for capture creation
                    allRelativePaths.push(relativePath);

                    // Only add to upload list if not skipped
                    if (!window.filesToSkip.has(fileKey)) {
                        filesToUpload.push(file);
                        relativePathsToUpload.push(relativePath);
                    }
                }

                // Show upload progress if there are files to upload
                if (filesToUpload.length > 0) {
                    progressSection.style.display = 'block';
                    progressMessage.textContent = 'Uploading files and creating captures...';
                    progressBar.style.width = '50%';
                    progressText.textContent = '50%';
                }





                // Upload files in chunks
                try {
                    // Update progress message for upload
                    progressMessage.textContent = 'Uploading files and creating captures...';

                    // Create AbortController for upload
                    const abortController = new AbortController();
                    currentAbortController = abortController;

                    // Chunk size for file uploads
                    const CHUNK_SIZE = 5;
                    const totalFiles = filesToUpload.length;
                    let uploadedFiles = 0;
                    let allResults = {
                        file_upload_status: 'success',
                        files: [],
                        captures: [],
                        errors: [],
                        message: ''
                    };

                    // Special case: if all files are skipped, send a single request without chunking
                    if (filesToUpload.length === 0) {
                        // Create form data for skipped files case
                        const skippedFormData = new FormData();

                        // Always add all relative paths for capture creation
                        allRelativePaths.forEach(path => {
                            skippedFormData.append('all_relative_paths', path);
                        });

                        // Add other form fields
                        const captureType = document.getElementById('captureTypeSelect').value;
                        skippedFormData.append('capture_type', captureType);

                        if (captureType === 'drf') {
                            const channels = document.getElementById('captureChannelsInput').value;
                            skippedFormData.append('channels', channels);
                        } else if (captureType === 'rh') {
                            const scanGroup = document.getElementById('captureScanGroupInput').value;
                            skippedFormData.append('scan_group', scanGroup);
                        }

                        // Don't send chunk information for skipped files
                        // This ensures capture creation happens

                        const response = await fetch("{% url 'users:upload_files' %}", {
                            method: 'POST',
                            body: skippedFormData,
                            signal: abortController.signal
                        });

                        const result = await response.json();

                        // Use the result directly
                        allResults = result;

                    } else {
                        // Upload files in chunks
                        for (let i = 0; i < filesToUpload.length; i += CHUNK_SIZE) {
                            const chunk = filesToUpload.slice(i, i + CHUNK_SIZE);
                            const chunkPaths = relativePathsToUpload.slice(i, i + CHUNK_SIZE);

                            // Calculate chunk information first
                            const totalChunks = Math.ceil(filesToUpload.length / CHUNK_SIZE);
                            const currentChunk = Math.floor(i / CHUNK_SIZE) + 1;
                            const isFinalChunk = currentChunk === totalChunks;

                            // Update progress
                            const progress = Math.round(((i + chunk.length) / totalFiles) * 100);
                            progressBar.style.width = progress + '%';
                            progressText.textContent = progress + '%';
                            progressMessage.textContent = `Uploading files ${i + 1}-${Math.min(i + CHUNK_SIZE, totalFiles)} of ${totalFiles} (chunk ${currentChunk}/${totalChunks})...`;

                            // Create form data for this chunk
                            const chunkFormData = new FormData();

                            // Add files for this chunk
                            chunk.forEach(file => {
                                chunkFormData.append('files', file);
                            });
                            chunkPaths.forEach(path => {
                                chunkFormData.append('relative_paths', path);
                            });

                            // Always add all relative paths for capture creation
                            allRelativePaths.forEach(path => {
                                chunkFormData.append('all_relative_paths', path);
                            });

                            // Add other form fields
                            const captureType = document.getElementById('captureTypeSelect').value;
                            chunkFormData.append('capture_type', captureType);

                            if (captureType === 'drf') {
                                const channels = document.getElementById('captureChannelsInput').value;
                                chunkFormData.append('channels', channels);
                            } else if (captureType === 'rh') {
                                const scanGroup = document.getElementById('captureScanGroupInput').value;
                                chunkFormData.append('scan_group', scanGroup);
                            }

                            // Add chunk information
                            chunkFormData.append('is_chunk', 'true');
                            chunkFormData.append('chunk_number', currentChunk.toString());
                            chunkFormData.append('total_chunks', totalChunks.toString());

                            // Check for cancellation before starting this chunk
                            if (cancelRequested) {
                                break; // Break out of the chunk loop
                            }

                            // Upload this chunk with timeout
                            const controller = new AbortController();
                            currentAbortController = controller; // Update current controller for this chunk
                            const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 minute timeout

                            let response;
                            let chunkResult;

                            try {
                                response = await fetch("{% url 'users:upload_files' %}", {
                                    method: 'POST',
                                    body: chunkFormData,
                                    signal: controller.signal
                                });

                                clearTimeout(timeoutId);

                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                }

                                chunkResult = await response.json();

                            } catch (error) {
                                clearTimeout(timeoutId);
                                if (error.name === 'AbortError') {
                                    throw new Error('Upload timeout - connection may be lost');
                                }
                                throw error;
                            }

                            // Merge results
                            if (chunkResult.files) {
                                allResults.files = allResults.files.concat(chunkResult.files);
                            }
                            // Only collect captures from the final chunk
                            if (chunkResult.captures && isFinalChunk) {
                                allResults.captures = allResults.captures.concat(chunkResult.captures);
                            }
                            if (chunkResult.errors) {
                                allResults.errors = allResults.errors.concat(chunkResult.errors);
                            }

                            uploadedFiles += chunk.length;

                            // Check if any chunk failed
                            if (chunkResult.file_upload_status === 'error') {
                                allResults.file_upload_status = 'error';
                                allResults.message = chunkResult.message || 'Upload failed';
                            } else if (chunkResult.file_upload_status === 'partial_success') {
                                allResults.file_upload_status = 'partial_success';
                            }

                            // Update status based on final chunk
                            if (isFinalChunk && chunkResult.file_upload_status === 'success') {
                                allResults.file_upload_status = 'success';
                            }

                            // Check if cancel was requested between chunks
                            if (cancelRequested) {
                                break; // Break out of the chunk loop
                            }
                        }
                    }

                    // Check if cancellation was requested during chunk upload
                    if (cancelRequested) {
                        // Small delay to ensure UI updates are visible
                        await new Promise(resolve => setTimeout(resolve, 100));
                        throw new Error('Upload cancelled by user');
                    }

                    // Clear the reference since upload completed
                    currentAbortController = null;



                    // Show results
                    showUploadResults(allResults, uploadedFiles, totalFiles);

                    // Don't auto-reload for successful uploads - let user close modal first
                } catch (error) {
                    if (cancelRequested) {
                        alert('Upload cancelled. Any files uploaded before cancellation have been saved.');
                        // Reload page after cancellation
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else if (error.name === 'AbortError') {
                        alert('Upload was interrupted. Any files uploaded before the interruption have been saved.');
                        // Reload page after interruption
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        // Don't show alert for network errors after page refresh
                        if (uploadInProgress || sessionStorage.getItem('uploadInProgress')) {
                            // Suppressing network error alert during active upload
                        } else {
                            alert('Network error during upload. Please check your connection and try again.');
                        }
                    } else {
                        alert('Upload failed: ' + error.message);
                        // Reload page after other errors
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    }
                } finally {
                    // Clean up UI state - ensure this always runs
                    resetUIState();
                }
            });

            // Function to reset UI state
            function resetUIState() {

                // Reset submit button
                submitButton.disabled = false;

                // Hide progress section
                const progressSection = document.getElementById('checkingProgressSection');
                if (progressSection) {
                    progressSection.style.display = 'none';
                }

                // Reset cancel button
                cancelButton.textContent = 'Cancel';
                cancelButton.classList.remove('btn-warning');
                cancelButton.disabled = false;

                // Reset progress elements
                const progressBar = document.getElementById('checkingProgressBar');
                const progressText = document.getElementById('checkingProgressText');
                const progressMessage = document.getElementById('progressMessage');

                if (progressBar) progressBar.style.width = '0%';
                if (progressText) progressText.textContent = '0%';
                if (progressMessage) progressMessage.textContent = '';

                // Reset state flags
                isProcessing = false;
                uploadInProgress = false;
                cancelRequested = false;

                // Clear session storage
                sessionStorage.removeItem('uploadInProgress');

                // Clear abort controller
                currentAbortController = null;
            }

            // Function to show upload results
            function showUploadResults(result, uploadedCount, totalCount) {
                // Check if page was refreshed during upload
                if (!uploadInProgress && result.file_upload_status === 'error') {
                    resetUIState(); // Ensure UI is reset even if modal is not shown
                    return;
                }

                let modalBody = document.getElementById('uploadResultModalBody');
                let resultModalEl = document.getElementById('uploadResultModal');
                let modal = new bootstrap.Modal(resultModalEl);

                // Close the upload modal before showing result modal
                const uploadModal = bootstrap.Modal.getInstance(document.getElementById('uploadCaptureModal'));
                if (uploadModal) {
                    uploadModal.hide();
                }



                let msg = '';
                if (result.file_upload_status === 'success' || result.file_upload_status === 'partial_success') {
                    // Use backend message if available, otherwise fall back to frontend logic
                    if (result.message) {
                        msg = `<b>${result.message}</b>`;
                    } else if (uploadedCount === 0 && totalCount > 0) {
                        // All files were skipped but captures were created
                        msg = `<b>Upload complete!</b><br />All ${totalCount} files already existed and were skipped.`;
                    } else {
                        // Some or all files were uploaded
                        msg = `<b>Upload complete!</b><br />Files uploaded: <strong>${uploadedCount}</strong> / ${totalCount}`;
                    }

                    if (result.captures && result.captures.length > 0) {
                        let uuids = result.captures.map(c => `<li>${c.uuid}</li>`).join('');
                        msg += `<br />Created capture UUID(s):<ul>${uuids}</ul>`;
                    }
                    if (result.errors && result.errors.length > 0) {
                        let errs = result.errors.map(e => `<li>${e}</li>`).join('');
                        msg += `<br /><b>Errors:</b><ul>${errs}</ul>`;
                    }
                } else {
                    msg = 'Upload failed: ' + (result.error || 'Unknown error');
                    if (result.errors && result.errors.length > 0) {
                        let errs = result.errors.map(e => `<li>${e}</li>`).join('');
                        msg += `<br /><b>Errors:</b><ul>${errs}</ul>`;
                    }
                }
                modalBody.innerHTML = msg;
                modal.show();

                // Add event listener to reload page when result modal is closed (only for successful uploads)
                if (result.file_upload_status === 'success' || result.file_upload_status === 'partial_success') {
                    resultModalEl.addEventListener('hidden.bs.modal', function() {
                        window.location.reload();
                    }, {
                        once: true
                    }); // Only trigger once per modal instance
                }
            }
        });
    </script>
    <!-- Capture Type Selection JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const captureTypeSelect = document.getElementById('captureTypeSelect');
            const channelInputGroup = document.getElementById('channelInputGroup');
            const scanGroupInputGroup = document.getElementById('scanGroupInputGroup');
            const captureChannelsInput = document.getElementById('captureChannelsInput');
            const captureScanGroupInput = document.getElementById('captureScanGroupInput');

            if (captureTypeSelect) {
                captureTypeSelect.addEventListener('change', function() {
                    const selectedType = this.value;

                    // Hide both input groups initially
                    if (channelInputGroup) channelInputGroup.classList.add('hidden-input-group');
                    if (scanGroupInputGroup) scanGroupInputGroup.classList.add('hidden-input-group');

                    // Clear required attributes
                    if (captureChannelsInput) captureChannelsInput.removeAttribute('required');
                    if (captureScanGroupInput) captureScanGroupInput.removeAttribute('required');

                    // Show appropriate input group based on selection
                    if (selectedType === 'drf') {
                        if (channelInputGroup) channelInputGroup.classList.remove('hidden-input-group');
                        if (captureChannelsInput) captureChannelsInput.setAttribute('required', 'required');
                    } else if (selectedType === 'rh') {
                        if (scanGroupInputGroup) scanGroupInputGroup.classList.remove('hidden-input-group');
                        // scan_group is optional for RadioHound captures
                    }
                });
            }

            // Reset form when modal is hidden
            const uploadModal = document.getElementById('uploadCaptureModal');
            if (uploadModal) {
                uploadModal.addEventListener('hidden.bs.modal', function() {
                    // Reset the form
                    const form = document.getElementById('uploadCaptureForm');
                    if (form) {
                        form.reset();
                    }

                    // Hide input groups
                    if (channelInputGroup) channelInputGroup.classList.add('hidden-input-group');
                    if (scanGroupInputGroup) scanGroupInputGroup.classList.add('hidden-input-group');

                    // Clear required attributes
                    if (captureChannelsInput) captureChannelsInput.removeAttribute('required');
                    if (captureScanGroupInput) captureScanGroupInput.removeAttribute('required');

                    // Clear file check status
                    const checkStatusDiv = document.getElementById('fileCheckStatus');
                    if (checkStatusDiv) {
                        checkStatusDiv.style.display = 'none';
                    }

                    // Clear status alerts and file details button
                    const uploadModalBody = document.querySelector('#uploadCaptureModal .modal-body');
                    const existingAlerts = uploadModalBody.querySelectorAll('.alert.alert-warning, .alert.alert-success');
                    existingAlerts.forEach(alert => {
                        if (alert.textContent.includes('will be skipped') || alert.textContent.includes('will be uploaded')) {
                            alert.remove();
                        }
                    });

                    // Remove file details button
                    const detailsLink = uploadModalBody.querySelector('#viewFileDetailsLink');
                    if (detailsLink) {
                        detailsLink.parentNode.remove();
                    }

                    // Clear global variables
                    window.filesToSkip.clear();
                    window.fileCheckResults.clear();
                });
            }
        });
    </script>
    <!-- This code calculates BLAKE3 hashes in the browser for file deduplication -->
    <!-- Load the WASM library first -->
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4.12.0/dist/blake3.umd.min.js"></script>
    <script>
        // Global variable to track files that should be skipped
        window.filesToSkip = new Set();
        window.fileCheckResults = new Map(); // Store detailed results for each file

        document.addEventListener('DOMContentLoaded', function() {
            var modal = document.getElementById('uploadCaptureModal');
            if (!modal) {
                console.warn('uploadCaptureModal not found');
                return;
            }
            modal.addEventListener('shown.bs.modal', function() {
                var fileInput = document.getElementById('captureFileInput');
                if (!fileInput) {
                    console.warn('captureFileInput not found');
                    return;
                }
                // Remove any previous handler to avoid duplicates
                fileInput.removeEventListener('change', window._blake3CaptureHandler);

                // Simple file handler that just stores the selected files
                window._blake3CaptureHandler = async function(event) {
                    const files = event.target.files;
                    if (!files || files.length === 0) {
                        return;
                    }

                    // Store the selected files for later processing
                    window.selectedFiles = Array.from(files);
                };
                fileInput.addEventListener('change', window._blake3CaptureHandler);
            });
        });

        // Remove old file checking functions - no longer needed
        // The checking is now done during upload with progress bar
    </script>
{% endblock javascript %}
